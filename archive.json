{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-12-08T02:00:30.831504+00:00",
  "repo": "davidjbrossard/alfa-authorization-language",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOMTtPW86Qg-gD",
      "title": "Shared conditions",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/1",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Repeating the same boolean logic throughout a policy is not only tedious but, from a maintenance perspective, does not scale.\r\n\r\nFrom a runtime perspective, it would be great not to repeat the execution of the same condition across policy decisions. \r\n\r\nConsider the following ALFA\r\n```\r\npolicy doorAccess {\r\n        target clause ResourceType == \"door\" and Action == \"open\"\r\n        apply denyUnlessPermit\r\n\r\n        // Employees can open the door during office hours only\r\n        rule mainDoor {\r\n            target clause Resource == \"mainDoor\"\r\n            permit\r\n            condition Subject.Role == 'employee' and\r\n                      CurrentTime >= \"08:00:00\":time and\r\n                      CurrentTime < \"18:00:00\":time\r\n        }\r\n    }\r\n```\r\n\r\nThe use of office opening hours could be part of a shared condition.\r\n\r\n```\r\n\r\ncondition IsOfficeOpen  CurrentTime >= \"08:00:00\":time &&   CurrentTime < \"18:00:00\":time\r\n\r\npolicy doorAccess {\r\n        target clause ResourceType == \"door\" && Action == \"open\"\r\n        apply denyUnlessPermit\r\n\r\n        // Employees can open the door during office hours only\r\n        rule mainDoor {\r\n            target clause Resource == \"mainDoor\"\r\n            permit\r\n            condition Subject.Role == 'employee' and IsOfficeOpen\r\n        }\r\n    }\r\n```\r\nUsing shared conditions allows the runtime to cache the result of a shared condition. Reducing the execution overhead.\r\n\r\nSome ALFA conditions can look complex, especially when multiple functions are called. The use of shared conditions increases the readability of ALFA and allows a clean separation between developers and policy builders. Developers can create shared conditions, and policy builders can create high-order conditions by combining shared conditions with boolean operators (and, or, not). This results in a form of ALFA that is\r\n\r\n- More readable\r\n- Possibility to execute faster when used multiple times in a policy evaluation\r\n- More maintainable \r\n\r\nThere is an argument to make conditions general-purpose expressions so they can return any result type, not just boolean. Keeping the contract to just boolean expressions creates a level of policy building that does not require deep technical knowledge. If policy conditions were built using shared expressions (return any type), a developer's refactor of the shared expression could break various policies, resulting in an error in the consumer of the shared expression, not in the author of the shared condition. A strong boolean contract prevents this from happening. This is not dissimilar to shared rules, which can only produce a permit or deny.\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2024-07-23T08:16:01Z",
      "updatedAt": "2024-07-23T08:16:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOMTtPW86QlIKo",
      "title": "Case insensitive string matching",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/2",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ALFA string comparisons using operators are case-sensitive. \r\n\r\nThe following expression is only true if the department has any value of \"engineering\" it will not be true for \"Engineering\"\r\n```\r\ndepartment == \"engineering\"\r\n```\r\n\r\n\r\nMany scenarios don't require this level of exact matching, so the condition has to use a function that performs the equality without being concerned by case.\r\n\r\n```\r\nIsEqualIgnoreCase(department,\"engineering\")\r\n```\r\n\r\nSuggest having a runtime option to make operator equality ignore case. This could be achieved by introducing an alfa.config file in the Policy Store.\r\n```\r\n{\r\n   \"stringEqualityIgnoreCase\" : true\r\n}\r\n```\r\n\r\nThere could be other runtime configuration options moving forward",
      "createdAt": "2024-07-23T16:44:26Z",
      "updatedAt": "2024-07-23T16:44:26Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOMTtPW86QpsCP",
      "title": "Implicit Attribute Identifier",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/3",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When defining an attribute in ALFA, the PIP (Policy Information Point) id of the attribute is often the same name as the attribute in ALFA\r\n\r\n```\r\nattribute department { type=string category=resourceCat id=\"department\" }\r\n```\r\n\r\nSuggest making the id optional. The value will be implicitly assigned based on the attribute name. Resulting in both code blocks having the equivalent functionality.\r\n\r\n```\r\nattribute department { type=string category=resourceCat  }\r\n```\r\n",
      "createdAt": "2024-07-24T07:51:47Z",
      "updatedAt": "2024-08-06T15:57:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "To be more specific, the ID will be the fully-qualified name (FQN) of the attribute e.g.\r\n\r\n````\r\nnamespace com.example{\r\n    attribute department{\r\n        type=string\r\n        category=resourceCat\r\n        // id = \"com.example.department\"\r\n    }\r\n}\r\n````",
          "createdAt": "2024-08-06T15:57:16Z",
          "updatedAt": "2024-08-06T15:57:16Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOMTtPW86Qp94d",
      "title": "Attribute Cardinality",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/4",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Attributes may contain 0 to many values, known as a bag. When using operators or functions that can only take a single value, the policy author may write less-than-ideal code.\r\n\r\n```\r\ncondition Single(netTotal) + Single(taxTotal) > 100\r\n```\r\n\r\nIdeally, the author would like to write.\r\n```\r\ncondition netTotal + taxTotal > 100\r\n```\r\n\r\n### Suggestions\r\n\r\n#### Attributes defined as single value\r\n\r\nDefine the attribute with a must-have cardinality of 1.\r\n\r\n```\r\nattribute single netTotal { type=double category=resourceCat  }\r\n```\r\n\r\nThis attribute can then be used with operators that take a single value or a bag of values (implicitly converted to a bag of 1). If the attribute has zero values, return an indeterminate decision. \r\n\r\n",
      "createdAt": "2024-07-24T08:29:07Z",
      "updatedAt": "2024-07-29T14:55:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOMTtPW86REvCY",
      "title": "Structured Attribute Datatype",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/5",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Attributes are bags of single values. \r\n\r\nInteger, double, boolean, string, date, time and dateTime\r\n\r\nScenarios exist that require each attribute bag item to contain multiple values.\r\n\r\nWhen modelling a user's set of specific permissions, having each attribute value contain both an action and the resource to which the action can be applied would be advantageous.\r\n\r\n### Suggestion\r\n\r\n```\r\ntype permission {\r\n  Action:string\r\n  ResourceType:string\r\n}\r\n\r\nattribute userPermissions { type = permission  category=resourceCat}\r\n```\r\nPIPs would then return a bag of values, each containing an Action and a ResourceType.\r\n\r\n\r\n#### Reasoning with complex attributes\r\n\r\nConsider the following ALFA\r\n\r\n```\r\ncondition userPermissions.Action == \"update\" and userPermissions.ResourceType == \"PurchaseOrders\"\r\n```\r\n\r\nWhere the userPersmissions bag is as follows ( Note: this example is shown in JSON, but there is no requirement for an ALFA implementation to serialise/deserialize JSON).\r\n\r\n```\r\n[ { Action:[\"UPDATE\"] , ResourceType:[\"Profile\",\"Photo\"] } ,\r\n  {Action:[\"READ\"],ResourceType[\"PurchaseOrder\"] }\r\n]\r\n```\r\n\r\nThis condition would be evaluated to true, as Permissions has an Action attribute set to UPDATE and a ResourceType Attribute set to PurchaseOrder. The intent is only to produce true if a single instance of the Permissions attribute has Action = \"UPDATE\" and ResourceType = \"PurchaseOrder\"\r\n\r\nTo solve this problem, we could consider the use pattern-matching style syntax\r\n\r\n```\r\ncondition Permissions[Action == \"UPDATE\"].ResourceType == \"PurchaseOrder\"\r\n```\r\n\r\nThe pattern-matching syntax is used to filter the attribute values. The above statement would only evaluate to true if the bag contained an item where the Action was UPDATE and ResourceType is \"PurchaseOrder\"\r\n\r\nMultiple expressions can be contained inside the [ ] operator.\r\n\r\n```\r\ncondition Permissions[Action == \"open\" and ResourceType==\"door\" ].Resource == \"MainDoor\"\r\n```\r\nThe use of [] operator does make ALFA less readable, however, combine this with shared conditions and developers could create a shared condition of CanOpenMainDoor\r\n\r\n```\r\ncondition CanOpenMainDoor Permissions[Action == \"open\" and ResourceType==\"door\" ].Resource == \"MainDoor\"\r\n. . .\r\n\r\npolicy DoorAccess \r\n{\r\n     apply firstApplicable\r\n     target clause ResourceType==\"door\" and Action ==\"open\"\r\n     rule {\r\n      condition CanOpenMainDoor\r\n      permit\r\n    }\r\n}\r\n```\r\n\r\n#### Questions\r\n\r\nDo we allow complex attributes to be made up of other complex attributes? \r\n\r\n",
      "createdAt": "2024-07-28T13:40:14Z",
      "updatedAt": "2024-11-21T17:45:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "What I wonder here is how much people will use (and abuse?) this type and stop using primitive types. Or how to correlate primitive types to complex types. Or, finally, how that impacts PIPs.",
          "createdAt": "2024-08-06T15:53:38Z",
          "updatedAt": "2024-08-06T15:53:38Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOMTtPW86RFWWo",
      "title": "Money type",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/6",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ALFA has an attribute type of double, but many platforms have a different type for dealing with currency that has increased precision.\r\n\r\nSuggest introducing a new type in ALFA called money\r\n\r\n```\r\nattribute cost { id=cost type=money category=resourceCat }\r\n```\r\n\r\n\r\n",
      "createdAt": "2024-07-28T20:28:02Z",
      "updatedAt": "2024-11-21T17:53:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "Oddly, XACML does not define decimal as one of its datatypes (although xs:decimal is mentioned in the context of XPath). The only numerical datatypes are double and integer. We should add support for decimal at least in ALFA but even suggest to the XACML TC that decimal be added.",
          "createdAt": "2024-11-21T17:53:12Z",
          "updatedAt": "2024-11-21T17:53:12Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOMTtPW86RFXNH",
      "title": "Constants",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/7",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Good programming languages provide developers with tools allowing them not to repeat themselves (COPY+PASTE); if a piece of logic changes, it may have to change in many places. \r\n\r\nFor example, the membership level attribute denotes a subscription level. \r\n\r\nBronze = 1\r\nSliver = 2\r\nGold = 3\r\n\r\n```\r\ncondition MembershipLevel > 1  // Allow Silver and above\r\n```\r\n\r\nThere may be multiple places in the policies wishing to do this kind of logic.\r\n\r\n#### Suggestion\r\n\r\nIntroduce defined constants\r\n\r\n```\r\nnamespace AmceHealth\r\n{\r\n define BronzeLevel = 1\r\n define SilverLevel = 2\r\n define GoldLevel = 3\r\n\r\n define Gym = \u201cgym\u201d\r\n define OpeningTime = \u201c09:00\u201d:time\r\n define ClosingTime = \u201c18:00\u201d:time\r\n\r\n\r\n attribute MembershipLevel {type=integer, category=SubjectCat}\r\n\r\n policy HealthClub\r\n {\r\n   rule {\r\n     deny condition not MembershipLevel > BronzeLevel\r\n   }\r\n\r\n   rule {\r\n \ttarget clause Action == \u201cbook\u201d and ResourceType == Gym\r\n \tpermit condition MembershipLevel > BronzeLevel\r\n   }\r\n } \r\n}\r\n```\r\n\r\nOther keyword suggestions other than **define** are\r\n- const\r\n- constant\r\n- let\r\n",
      "createdAt": "2024-07-28T20:39:34Z",
      "updatedAt": "2024-07-29T15:00:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOMTtPW86SGfDq",
      "title": "Simplify advice and obligation assignment",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/8",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nThe following obligation assigns the Action attribute to the obligation with the same value as the Action attribute has in the current context.\r\n\r\n```\r\n   on permit\r\n        {\r\n            obligation Audit\r\n            {\r\n                When = CurrentDateTime\r\n                Who = Subject.Email\r\n                Description = \"Accessed the Purchase Order system\"\r\n                Action = Action\r\n            }\r\n        }\r\n```\r\n\r\nSuggest simplifying to\r\n\r\n```\r\n   on permit\r\n        {\r\n            obligation Audit\r\n            {\r\n                When = CurrentDateTime\r\n                Who = Subject.Email\r\n                Description = \"Accessed the Purchase Order system\"\r\n                Action \r\n            }\r\n        }\r\n```\r\n",
      "createdAt": "2024-08-06T15:31:54Z",
      "updatedAt": "2024-11-28T08:29:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "Agreed. The annoying thing with advice/obligations is to have to specify the name of the placeholder even when the content itself could be used as the name of the placeholder (Action = Action vs Action).",
          "createdAt": "2024-11-21T17:31:15Z",
          "updatedAt": "2024-11-21T17:31:15Z"
        },
        {
          "author": "TheoDimitrakos",
          "authorAssociation": "COLLABORATOR",
          "body": "In general I agree with the principle  of using content itself  as a placeholder where possible but it is not clear to me why and how this can simpify obligations specifically. \r\n\r\nWhat is the syntax of the obligation in this situation and why are  attributes for When, Who, Description and Action are treated  differently. \r\n\r\nDo you assume that Obligation  Audit is defined to have aonly one Action and this Action has value Action?  \r\n\r\nWhat if there were multiple possible asction values assocaited with an oblgiation like  Action acttribute can have values Action1 and Action2 ?   Would that make Action1 and Action2 different placeholders or Aciton placeholder with different values ? \r\n\r\nWould it be \r\n\r\n  on permit\r\n        {\r\n            obligation Audit\r\n            {\r\n                When = CurrentDateTime\r\n                Who = Subject.Email\r\n                Description = \"Accessed the Purchase Order system\"\r\n                Action1  \r\n            }\r\n        }\r\n\r\nor\r\n  \r\non permit\r\n        {\r\n            obligation Audit\r\n            {\r\n                When = CurrentDateTime\r\n                Who = Subject.Email\r\n                Description = \"Accessed the Purchase Order system\"\r\n                Action  = Action1  \r\n            }\r\n        }\r\n",
          "createdAt": "2024-11-28T08:25:06Z",
          "updatedAt": "2024-11-28T08:29:38Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOMTtPW86SGrUL",
      "title": "Make attribute type optional",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/9",
      "state": "CLOSED",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "- **Summary**: Make attribute type optional. It\u2019s \u201cstring\u201d by default. If you need a different datatype, specify it as you do today.",
      "createdAt": "2024-08-06T15:58:19Z",
      "updatedAt": "2024-08-06T15:59:33Z",
      "closedAt": "2024-08-06T15:59:25Z",
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "\r\nWe decided against this feature. Some 'defaults' are healthy. Others are asking for trouble. It is best to be explicit when it comes to types. (E.g. JS vs TS)\r\n\r\n",
          "createdAt": "2024-08-06T15:59:25Z",
          "updatedAt": "2024-08-06T15:59:25Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOMTtPW86SGw4L",
      "title": "Simplify overall language structure",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/10",
      "state": "OPEN",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "ALFA, like XACML, has a 3-level structure:\r\n- PolicySet\r\n- Policy\r\n- Rule\r\n\r\nALFA 2.0 aims to simplify into Policy only. Rule and PolicySet are folded into Policy. Combining algorithms are updated accordingly.",
      "createdAt": "2024-08-06T16:11:23Z",
      "updatedAt": "2024-11-29T08:28:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "andrewclymer",
          "authorAssociation": "COLLABORATOR",
          "body": "I can see how a policy could contain rules and references to other policies, but I need clarification on how you can remove the rules.",
          "createdAt": "2024-08-07T08:08:13Z",
          "updatedAt": "2024-08-07T08:08:13Z"
        },
        {
          "author": "TheoDimitrakos",
          "authorAssociation": "COLLABORATOR",
          "body": "suggestion - need to copy detail from slack \r\n\r\n1 A policy is a structure (complex attribute)  consisting of \r\n1.1\tTarget  where the assigned value is a selector function (prefer boolean condition as in our implementation but in xacml it is a matching function) \r\n1.2\tCondition where the assigned value is a boolean function  \r\n1.3\tEffect where the assigned value is PERMIT, DENY or the value of the Evaluation Constructor that takes as input a policy combination algorithm and a collection of policies \r\n1.4\tObligations are assignments of obligation instructions on Effect values\r\nOptionally add \r\n1.5       policy issuance characteristics (bag of attributes about issuer, level of assurance, etc) \r\n\r\n\r\n2\tThe evaluation function constructor takes a policy and produces and Effect value and an array of obligations associated with this effect. It is defined as follows \r\n2.1\t\u2013an evaluation function of an atomic policy is \r\n2.1.1\tINAPPLICABLE if the selector assignment does not hold\r\n2.1.2\tINAPPLICABLE if the selector assignment hold but the condition does not hold \r\n2.1.3\tThe value specified in Effect if both selector assignment and condition hold  \r\n2.1.4\tINDETERMINATE if the evaluation function fails to compute (e.g. due to undefined attribute values, etc.)    \r\n2.2\t\u2013 an evaluation function of a composite policy is composition of subordinate evaluation functions in accordance to declared policy combination algorithm \r\n\r\nIdeally we should have proper typic and namespace management for policies \r\nIeeally PERMIT, DENY could be values that are specific to authoirzation and in general someon could define values other than PERMIT or DENY as long as policy combination algorithms are updated accordingly.  The only fixed values of desion shoud be inherited from the evaluator constructur definition and be NOT APPLICABLE (meaning skip) and  INDETERMINATE  (meaning undefined) \r\n",
          "createdAt": "2024-11-22T14:18:53Z",
          "updatedAt": "2024-11-22T14:18:53Z"
        },
        {
          "author": "andrewclymer",
          "authorAssociation": "COLLABORATOR",
          "body": "What other values do you think there could be other than PERMIT or DENY?",
          "createdAt": "2024-11-26T17:17:23Z",
          "updatedAt": "2024-11-26T17:17:23Z"
        },
        {
          "author": "TheoDimitrakos",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n1 For simple and stateless access control, PERMIT or DENY is sufficient. \r\n\r\n2 USAGE CONTROL and STATEFUL  AUTHORIZATION \r\nFor a more general sateful authorizations, there may be other decision options that are used to determine transitions between states. See for example https://dl.acm.org/doi/epdf/10.1145/3532105.3535039   where one can imagine the system to produce different decisions depending on the state and the evaluation of the policy for the applicable state.  For example, if the state is \"collection\" a permission decision would be interpreted as a permission to continue collecting data whereas a \"data collected\" decision would be interpreted as a confirmation of sufficient data been collected and collection obligations about anonymization etc being fullfiled, and allow an update of the state attribute from \"collection\" to \"retention\" . \r\n\r\n[SACMAT2022-3532105.3535039.pdf](https://github.com/user-attachments/files/17932870/SACMAT2022-3532105.3535039.pdf)\r\n\r\n3 PRIVILEGE ASSIGNMENT \r\nIf one wanted to implement privilege management decisions could be associated with capabilities provisioned as opposed to PERMIT or DENY.  \r\n\r\n4 OBLIGATION CLASSIFICATION\r\nAnother case could be if one wants to have policy decisions that are associated with different groups of obligations, it is difficult to characterize those obligation groups with a single policy decision, hence the separation between such groups of obligations are necessary.  One could give \"Limited access\" to requestor or \"Full access\"  depending some polciy combination and environmental attributes. Each of these decissions may implement different obligations or link to different privileges.",
          "createdAt": "2024-11-27T10:21:55Z",
          "updatedAt": "2024-11-27T10:32:01Z"
        },
        {
          "author": "TheoDimitrakos",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nThe above can be summarized in the following diagram that shows  the simplificaiton from ALFA.1.0 to ALFA.2.0 and the backwards compability through specialziation \r\n\r\n![image](https://github.com/user-attachments/assets/4f14eabb-f6fc-413d-b44d-1f779ebb554d)\r\n\r\n\r\n\r\nThe following comments help clarify the data model diagram.  \r\nI suggest a simpler and more abstract data model where \r\n\r\n(1) ALFA.2.0  tPolicy can optionally have a Condition  - as per Axiomatics ALFA  - and ommitting the condition statement would equate to True and Issuer (that acan also be omitted)  \r\n\r\n(2) Decision can be either Combining Algorithm or Effect (xor). This a specialization that facilitates backwards compatibilty with ALFA.1.0 \r\n\r\n(3)  Action is a generalziation of  Obligation and Advice \r\n\r\nthen we have a simpler data model that has only \r\n\r\nPolicy\r\nAction  \r\n\r\nThen the simple data model specialization for  (backwards compatible) ALFA.1 becomes the same as in Andy's picture where \r\n\r\nAFA1.0 Policy is a specialization of  ALFA.2.0 Policy where \r\n* Issuer is omitted (?) \r\n* Condition is omitted  (hence true) \r\n* Decision is Combining Algorithm\r\n\r\nALFA.1.0 Rule is a specialization of ALFA.2.0 Policy where \r\n* Issuer is omitted \r\n* Decision is Effect  \r\n\r\nALFA.1.0 Obligation is a specialization of  ALFA.2.0 Action (where the expectation is commitment to enforce) \r\n\r\nALFA.1.0 Advice is a specialization of ALFA.2.0 Action (where the expectation is optional to enforce)\r\n",
          "createdAt": "2024-11-29T08:21:26Z",
          "updatedAt": "2024-11-29T08:28:11Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOMTtPW86fwZx8",
      "title": "Default combining algorithm",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/11",
      "state": "CLOSED",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Introduce a default combining algorithm and stop requiring one be provided: let\u2019s use either \u2018first-applicable\u2019 or \u2018deny-overrides\u2019",
      "createdAt": "2024-11-21T17:17:30Z",
      "updatedAt": "2024-11-21T17:18:14Z",
      "closedAt": "2024-11-21T17:18:14Z",
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "We decided against an invisible default combining algorithm for now.",
          "createdAt": "2024-11-21T17:17:52Z",
          "updatedAt": "2024-11-21T17:17:52Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOMTtPW86fwbVK",
      "title": "Overload all functions: get rid of typeEquals and replace with overloaded method equals (less than, gt, \u2026)",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/12",
      "state": "OPEN",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "For instance we have 2 functions:\r\n\r\n- booleanAtLeastOneMemberOf\r\n- anyURIAtLeastOneMemberOf\r\n\r\nthat relate to being members. We should just have one method (atLeastOneMemberOf) regardless of type.\r\n\r\n\r\n",
      "createdAt": "2024-11-21T17:20:39Z",
      "updatedAt": "2024-11-21T17:20:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOMTtPW86fwcti",
      "title": "Rename common functions to use developer-friendly names",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/13",
      "state": "OPEN",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Rename common functions to use developer-friendly names e.g.:\r\n`stringNormalizeToLowerCase` should be renamed to `toLower` or `lower`.\r\n\r\nThe entire list of function names can be found in system.alfa in the ALFA Plugin for VS Code.",
      "createdAt": "2024-11-21T17:23:39Z",
      "updatedAt": "2024-11-21T17:23:40Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOMTtPW86fwev1",
      "title": "Get rid of advice",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/14",
      "state": "CLOSED",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "XACML and ALFA both define:\r\n- advice\r\n- obligation\r\nBoth elements are identical in structure and content but differ in intent: the PEP must comply with an obligation while it may comply with an advice. To simplify the language we could keep obligation and add a boolean flag that tells the PEP whether it has to understand and process the obligation. ",
      "createdAt": "2024-11-21T17:28:05Z",
      "updatedAt": "2024-11-21T17:28:37Z",
      "closedAt": "2024-11-21T17:28:37Z",
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "Switching from 2 elements (advice and obligation) to a single one with a new parameter (the flag) is too much work for now and not worth it. We can revisit later.",
          "createdAt": "2024-11-21T17:28:37Z",
          "updatedAt": "2024-11-21T17:28:37Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOMTtPW86fwt9c",
      "title": "Simplify bag to atomic value syntax",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/15",
      "state": "OPEN",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "![image](https://github.com/user-attachments/assets/a9d856ba-7dcf-47b0-abde-5630c54e26d9)\r\n\r\n**Example**:\r\n\r\n- `map(function[stringNormalizeToLowerCase],user.region)`\r\n- Just do: `lower(user.region)`  Or\u2026 `user.region.toLower()`\r\n",
      "createdAt": "2024-11-21T17:38:34Z",
      "updatedAt": "2024-11-21T17:44:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "Also: review higher-order functions and offer reasonably named alternatives and syntactic sugar e.g. `user.region.equals(doc.regions)`",
          "createdAt": "2024-11-21T17:44:07Z",
          "updatedAt": "2024-11-21T17:44:07Z"
        }
      ]
    }
  ],
  "pulls": []
}