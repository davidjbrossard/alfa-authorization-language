{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-10-31T01:46:08.315134+00:00",
  "repo": "davidjbrossard/alfa-authorization-language",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOMTtPW86Qg-gD",
      "title": "Shared conditions",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/1",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Repeating the same boolean logic throughout a policy is not only tedious but, from a maintenance perspective, does not scale.\r\n\r\nFrom a runtime perspective, it would be great not to repeat the execution of the same condition across policy decisions. \r\n\r\nConsider the following ALFA\r\n```\r\npolicy doorAccess {\r\n        target clause ResourceType == \"door\" and Action == \"open\"\r\n        apply denyUnlessPermit\r\n\r\n        // Employees can open the door during office hours only\r\n        rule mainDoor {\r\n            target clause Resource == \"mainDoor\"\r\n            permit\r\n            condition Subject.Role == 'employee' and\r\n                      CurrentTime >= \"08:00:00\":time and\r\n                      CurrentTime < \"18:00:00\":time\r\n        }\r\n    }\r\n```\r\n\r\nThe use of office opening hours could be part of a shared condition.\r\n\r\n```\r\n\r\ncondition IsOfficeOpen  CurrentTime >= \"08:00:00\":time &&   CurrentTime < \"18:00:00\":time\r\n\r\npolicy doorAccess {\r\n        target clause ResourceType == \"door\" && Action == \"open\"\r\n        apply denyUnlessPermit\r\n\r\n        // Employees can open the door during office hours only\r\n        rule mainDoor {\r\n            target clause Resource == \"mainDoor\"\r\n            permit\r\n            condition Subject.Role == 'employee' and IsOfficeOpen\r\n        }\r\n    }\r\n```\r\nUsing shared conditions allows the runtime to cache the result of a shared condition. Reducing the execution overhead.\r\n\r\nSome ALFA conditions can look complex, especially when multiple functions are called. The use of shared conditions increases the readability of ALFA and allows a clean separation between developers and policy builders. Developers can create shared conditions, and policy builders can create high-order conditions by combining shared conditions with boolean operators (and, or, not). This results in a form of ALFA that is\r\n\r\n- More readable\r\n- Possibility to execute faster when used multiple times in a policy evaluation\r\n- More maintainable \r\n\r\nThere is an argument to make conditions general-purpose expressions so they can return any result type, not just boolean. Keeping the contract to just boolean expressions creates a level of policy building that does not require deep technical knowledge. If policy conditions were built using shared expressions (return any type), a developer's refactor of the shared expression could break various policies, resulting in an error in the consumer of the shared expression, not in the author of the shared condition. A strong boolean contract prevents this from happening. This is not dissimilar to shared rules, which can only produce a permit or deny.\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2024-07-23T08:16:01Z",
      "updatedAt": "2024-07-23T08:16:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOMTtPW86QlIKo",
      "title": "Case insensitive string matching",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/2",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ALFA string comparisons using operators are case-sensitive. \r\n\r\nThe following expression is only true if the department has any value of \"engineering\" it will not be true for \"Engineering\"\r\n```\r\ndepartment == \"engineering\"\r\n```\r\n\r\n\r\nMany scenarios don't require this level of exact matching, so the condition has to use a function that performs the equality without being concerned by case.\r\n\r\n```\r\nIsEqualIgnoreCase(department,\"engineering\")\r\n```\r\n\r\nSuggest having a runtime option to make operator equality ignore case. This could be achieved by introducing an alfa.config file in the Policy Store.\r\n```\r\n{\r\n   \"stringEqualityIgnoreCase\" : true\r\n}\r\n```\r\n\r\nThere could be other runtime configuration options moving forward",
      "createdAt": "2024-07-23T16:44:26Z",
      "updatedAt": "2024-07-23T16:44:26Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOMTtPW86QpsCP",
      "title": "Implicit Attribute Identifier",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/3",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When defining an attribute in ALFA, the PIP (Policy Information Point) id of the attribute is often the same name as the attribute in ALFA\r\n\r\n```\r\nattribute department { type=string category=resourceCat id=\"department\" }\r\n```\r\n\r\nSuggest making the id optional. The value will be implicitly assigned based on the attribute name. Resulting in both code blocks having the equivalent functionality.\r\n\r\n```\r\nattribute department { type=string category=resourceCat  }\r\n```\r\n",
      "createdAt": "2024-07-24T07:51:47Z",
      "updatedAt": "2024-08-06T15:57:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "To be more specific, the ID will be the fully-qualified name (FQN) of the attribute e.g.\r\n\r\n````\r\nnamespace com.example{\r\n    attribute department{\r\n        type=string\r\n        category=resourceCat\r\n        // id = \"com.example.department\"\r\n    }\r\n}\r\n````",
          "createdAt": "2024-08-06T15:57:16Z",
          "updatedAt": "2024-08-06T15:57:16Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOMTtPW86Qp94d",
      "title": "Attribute Cardinality",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/4",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Attributes may contain 0 to many values, known as a bag. When using operators or functions that can only take a single value, the policy author may write less-than-ideal code.\r\n\r\n```\r\ncondition Single(netTotal) + Single(taxTotal) > 100\r\n```\r\n\r\nIdeally, the author would like to write.\r\n```\r\ncondition netTotal + taxTotal > 100\r\n```\r\n\r\n### Suggestions\r\n\r\n#### Attributes defined as single value\r\n\r\nDefine the attribute with a must-have cardinality of 1.\r\n\r\n```\r\nattribute single netTotal { type=double category=resourceCat  }\r\n```\r\n\r\nThis attribute can then be used with operators that take a single value or a bag of values (implicitly converted to a bag of 1). If the attribute has zero values, return an indeterminate decision. \r\n\r\n",
      "createdAt": "2024-07-24T08:29:07Z",
      "updatedAt": "2024-07-29T14:55:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOMTtPW86REvCY",
      "title": "Complex Attributes",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/5",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Attributes are bags of single values. \r\n\r\nInteger, double, boolean, string, date, time and dateTime\r\n\r\nScenarios exist that require each attribute bag item to contain multiple values.\r\n\r\nWhen modelling a user's set of specific permissions, having each attribute value contain both an action and the resource to which the action can be applied would be advantageous.\r\n\r\n### Suggestion\r\n\r\n```\r\ntype permission {\r\n  Action:string\r\n  ResourceType:string\r\n}\r\n\r\nattribute userPermissions { type = permission  category=resourceCat}\r\n```\r\nPIPs would then return a bag of values, each containing an Action and a ResourceType.\r\n\r\n\r\n#### Reasoning with complex attributes\r\n\r\nConsider the following ALFA\r\n\r\n```\r\ncondition userPermissions.Action == \"update\" and userPermissions.ResourceType == \"PurchaseOrders\"\r\n```\r\n\r\nWhere the userPersmissions bag is as follows ( Note: this example is shown in JSON, but there is no requirement for an ALFA implementation to serialise/deserialize JSON).\r\n\r\n```\r\n[ { Action:[\"UPDATE\"] , ResourceType:[\"Profile\",\"Photo\"] } ,\r\n  {Action:[\"READ\"],ResourceType[\"PurchaseOrder\"] }\r\n]\r\n```\r\n\r\nThis condition would be evaluated to true, as Permissions has an Action attribute set to UPDATE and a ResourceType Attribute set to PurchaseOrder. The intent is only to produce true if a single instance of the Permissions attribute has Action = \"UPDATE\" and ResourceType = \"PurchaseOrder\"\r\n\r\nTo solve this problem, we could consider the use pattern-matching style syntax\r\n\r\n```\r\ncondition Permissions[Action == \"UPDATE\"].ResourceType == \"PurchaseOrder\"\r\n```\r\n\r\nThe pattern-matching syntax is used to filter the attribute values. The above statement would only evaluate to true if the bag contained an item where the Action was UPDATE and ResourceType is \"PurchaseOrder\"\r\n\r\nMultiple expressions can be contained inside the [ ] operator.\r\n\r\n```\r\ncondition Permissions[Action == \"open\" and ResourceType==\"door\" ].Resource == \"MainDoor\"\r\n```\r\nThe use of [] operator does make ALFA less readable, however, combine this with shared conditions and developers could create a shared condition of CanOpenMainDoor\r\n\r\n```\r\ncondition CanOpenMainDoor Permissions[Action == \"open\" and ResourceType==\"door\" ].Resource == \"MainDoor\"\r\n. . .\r\n\r\npolicy DoorAccess \r\n{\r\n     apply firstApplicable\r\n     target clause ResourceType==\"door\" and Action ==\"open\"\r\n     rule {\r\n      condition CanOpenMainDoor\r\n      permit\r\n    }\r\n}\r\n```\r\n\r\n#### Questions\r\n\r\nDo we allow complex attributes to be made up of other complex attributes? \r\n\r\n",
      "createdAt": "2024-07-28T13:40:14Z",
      "updatedAt": "2024-08-20T15:35:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "What I wonder here is how much people will use (and abuse?) this type and stop using primitive types. Or how to correlate primitive types to complex types. Or, finally, how that impacts PIPs.",
          "createdAt": "2024-08-06T15:53:38Z",
          "updatedAt": "2024-08-06T15:53:38Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOMTtPW86RFWWo",
      "title": "Money type",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/6",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ALFA has an attribute type of double, but many platforms have a different type for dealing with currency that has increased precision.\r\n\r\nSuggest introducing a new type in ALFA called money\r\n\r\n```\r\nattribute cost { id=cost type=money category=resourceCat }\r\n```\r\n\r\n\r\n",
      "createdAt": "2024-07-28T20:28:02Z",
      "updatedAt": "2024-07-29T14:56:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOMTtPW86RFXNH",
      "title": "Constants",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/7",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Good programming languages provide developers with tools allowing them not to repeat themselves (COPY+PASTE); if a piece of logic changes, it may have to change in many places. \r\n\r\nFor example, the membership level attribute denotes a subscription level. \r\n\r\nBronze = 1\r\nSliver = 2\r\nGold = 3\r\n\r\n```\r\ncondition MembershipLevel > 1  // Allow Silver and above\r\n```\r\n\r\nThere may be multiple places in the policies wishing to do this kind of logic.\r\n\r\n#### Suggestion\r\n\r\nIntroduce defined constants\r\n\r\n```\r\nnamespace AmceHealth\r\n{\r\n define BronzeLevel = 1\r\n define SilverLevel = 2\r\n define GoldLevel = 3\r\n\r\n define Gym = \u201cgym\u201d\r\n define OpeningTime = \u201c09:00\u201d:time\r\n define ClosingTime = \u201c18:00\u201d:time\r\n\r\n\r\n attribute MembershipLevel {type=integer, category=SubjectCat}\r\n\r\n policy HealthClub\r\n {\r\n   rule {\r\n     deny condition not MembershipLevel > BronzeLevel\r\n   }\r\n\r\n   rule {\r\n \ttarget clause Action == \u201cbook\u201d and ResourceType == Gym\r\n \tpermit condition MembershipLevel > BronzeLevel\r\n   }\r\n } \r\n}\r\n```\r\n\r\nOther keyword suggestions other than **define** are\r\n- const\r\n- constant\r\n- let\r\n",
      "createdAt": "2024-07-28T20:39:34Z",
      "updatedAt": "2024-07-29T15:00:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOMTtPW86SGfDq",
      "title": "Simplify advice and obligation assignment",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/8",
      "state": "OPEN",
      "author": "andrewclymer",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nThe following obligation assigns the Action attribute to the obligation with the same value as the Action attribute has in the current context.\r\n\r\n```\r\n   on permit\r\n        {\r\n            obligation Audit\r\n            {\r\n                When = CurrentDateTime\r\n                Who = Subject.Email\r\n                Description = \"Accessed the Purchase Order system\"\r\n                Action = Action\r\n            }\r\n        }\r\n```\r\n\r\nSuggest simplifying to\r\n\r\n```\r\n   on permit\r\n        {\r\n            obligation Audit\r\n            {\r\n                When = CurrentDateTime\r\n                Who = Subject.Email\r\n                Description = \"Accessed the Purchase Order system\"\r\n                Action \r\n            }\r\n        }\r\n```\r\n",
      "createdAt": "2024-08-06T15:31:54Z",
      "updatedAt": "2024-08-06T15:31:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOMTtPW86SGrUL",
      "title": "Make attribute type optional",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/9",
      "state": "CLOSED",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "- **Summary**: Make attribute type optional. It\u2019s \u201cstring\u201d by default. If you need a different datatype, specify it as you do today.",
      "createdAt": "2024-08-06T15:58:19Z",
      "updatedAt": "2024-08-06T15:59:33Z",
      "closedAt": "2024-08-06T15:59:25Z",
      "comments": [
        {
          "author": "davidjbrossard",
          "authorAssociation": "OWNER",
          "body": "\r\nWe decided against this feature. Some 'defaults' are healthy. Others are asking for trouble. It is best to be explicit when it comes to types. (E.g. JS vs TS)\r\n\r\n",
          "createdAt": "2024-08-06T15:59:25Z",
          "updatedAt": "2024-08-06T15:59:25Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOMTtPW86SGw4L",
      "title": "Simplify overall language structure",
      "url": "https://github.com/davidjbrossard/alfa-authorization-language/issues/10",
      "state": "OPEN",
      "author": "davidjbrossard",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "ALFA, like XACML, has a 3-level structure:\r\n- PolicySet\r\n- Policy\r\n- Rule\r\n\r\nALFA 2.0 aims to simplify into Policy only. Rule and PolicySet are folded into Policy. Combining algorithms are updated accordingly.",
      "createdAt": "2024-08-06T16:11:23Z",
      "updatedAt": "2024-08-07T08:08:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "andrewclymer",
          "authorAssociation": "COLLABORATOR",
          "body": "I can see how a policy could contain rules and references to other policies, but I need clarification on how you can remove the rules.",
          "createdAt": "2024-08-07T08:08:13Z",
          "updatedAt": "2024-08-07T08:08:13Z"
        }
      ]
    }
  ],
  "pulls": []
}